#!/usr/bin/python

# Copyright 2009-2013 Eucalyptus Systems, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.
#
# Please contact Eucalyptus Systems, Inc., 6755 Hollister Ave., Goleta
# CA 93117, USA or visit http://www.eucalyptus.com/licenses/ if you need
# additional information or have any questions.

# main
import os
from pprint import pprint
import shutil
import subprocess
import tempfile
import argparse
import sys
from eucatoolkit.stages.downloadimage import DownloadImage

class WF_InsufficientArguments(RuntimeError):
    pass


class WF_InsufficientDependencies(RuntimeError):
    pass

# base workflow class

class WF_base():
    def __init__(self):
        self.id = 'unset'
        self.problems = [] # list of problems (implying workflow is not usable)
        self.description = self.__doc__
        self.euca_imager = "euca-imager"

    def add_arguments(self, name, subparsers):
        pass

    def check_deps(self, args):
        pass

    def execute(self, args):
        if len(self.problems) > 0:
            raise WF_InsufficientDependencies(self.problems)
        print "running workflow '" + args.name + "'"

# specific workflows, one per class

class WF_DownBundleFS_UpBundle(WF_base):
    """Downloads a file-system bundle, converting to a disk, uploads"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_down_bundle_args(parser)
        parser.add_argument('--kernel-manifest-url', required=True, metavar='URL', help='URL of the download manifest for the kernel bundle')
        parser.add_argument('--ramdisk-manifest-url', required=True, metavar='URL', help='URL of the downlaod manifest for the ramdisk bundle')
        _add_up_bundle_args(parser)
        parser.add_argument('--work-dir', required=True, metavar='PATH', help='Path to the directory where temporary work files are to reside')

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)
        self.problems = _check_imager(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)
        work_dir = tempfile.mkdtemp(dir=args.work_dir, prefix='euca-workflow-')
        print "working in directory: " + work_dir
        try:
            # (1) download the needed ingredients
            partition_path = _download_image(work_dir, args.prefix + ".partition", args.image_manifest_url, args.decryption_key_path)
            kernel_path = _download_image(work_dir, args.prefix + ".kernel", args.kernel_manifest_url, args.decryption_key_path)
            ramdisk_path = _download_image(work_dir, args.prefix + ".ramdisk", args.ramdisk_manifest_url, args.decryption_key_path)

            # (2) convert partition into a disk
            convert_args = [self.euca_imager,
                            'debug=true',
                            'fsck']
            convert_ps = subprocess.Popen(convert_args)
            convert_ps.wait()

            # (3) bundle and upload the disk

        finally: # cleanup
            shutil.rmtree(work_dir)

class WF_DownBundle_WriteRaw(WF_base):
    """Downloads a bundle, writes its contents to a file/device"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_down_bundle_args(parser)
        parser.add_argument('--output-path', required=True, metavar='PATH', help="Path to the file or block device to write output into")

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)
        download = DownloadImage(debug=True, manifest=args.image_manifest_url, destination=args.output_path, privatekey=args.decryption_key_path)
        download.main()

class WF_DownBundle_UpVMDK(WF_base):
    """Downloading a bundle, uploads its contents to datastore as VMDK"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_down_bundle_args(parser)
        _add_vmdk_args(parser)

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)

class WF_ReadRaw_UpBundle(WF_base):
    """Bundles contents of a local file/disk and uploads it to Object Store"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        parser.add_argument('--input-path', required=True, metavar='PATH', help="Path to the file or block device to read from")
        _add_up_bundle_args(parser)

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)

class WF_DownVMDK_UpBundle(WF_base):
    """Downloads a remote VMDK, bundles the disk, and uploads it to Object Store"""

    def add_arguments(self, id, subparsers):
        self.id = id
        parser = subparsers.add_parser(id, help='a help')
        _add_vmdk_args(parser)
        _add_up_bundle_args(parser)

    def check_deps(self, args):
        self.problems = _check_euca2ools(self.problems)

    def execute(self, args):
        WF_base.execute(self, args)

# helpers for arguments shared by more than one workflow

def _add_down_bundle_args(parser):
    parser.add_argument('--decryption-key-path', required=True, metavar='PATH',  help="Path to the key for decryption")
    parser.add_argument('--image-manifest-url', required=True, metavar='URL', help="URL of the download manifest for the bundle")

def _add_up_bundle_args(parser):
    parser.add_argument('--signing-key-path', required=True, metavar='PATH',  help="Path to the key for signing the manifest")
    parser.add_argument('--encryption-cert-path', required=True, metavar='PATH', help="Path to the certificate to use for encrypting the bundle")
    parser.add_argument('--prefix', required=True, metavar='NAME', help="File name prefix to give the bundle's files")
    parser.add_argument('--bucket', required=True, metavar='NAME', help="Name of the bucket to upload the bundle into")

def _add_vmdk_args(parser):
    parser.add_argument('--vsphere-login', required=True, metavar='NAME',  help="Login for the VMware endpoint")
    parser.add_argument('--vsphere-password', required=True, metavar='PASSWORD',  help="Password for the VMware endpoint")
    parser.add_argument('--vsphere-datacenter', required=True, metavar='NAME',  help="Name of the datacenter containing the VM")
    parser.add_argument('--vsphere-vmdk', required=True, metavar='PATH',  help="Path of the VMDK, including the datastore")
    parser.add_argument('--vsphere-vmx', required=True, metavar='PATH',  help="Path of the VMX, including the datastore")

def _download_image(work_dir, name, url, key):
    dest = os.path.join(work_dir, name)
    download = DownloadImage(reportprogress=True, manifest=url, destination=dest, privatekey=key)
    download.main()
    return dest

# checking helpers to detect presence of dependencies

def _check_executable(problems, command, dep_name):
    with open(os.devnull, "w") as fnull:
        try:
            err = subprocess.call(command, stdout=fnull, stderr=fnull)
            if (err != 0):
                raise ReferenceError
        except:
            problems.append(dep_name + ' is missing')


def _check_euca2ools(problems):
    _check_executable(problems, ["euca-version"], "euca2ools")
    return problems

def _check_imager(problems):
    _check_executable(problems, ["euca-imager"], "euca-imager")
    return problems

WORKFLOWS = {'down-bundle-fs/up-bundle': WF_DownBundleFS_UpBundle(),
             'down-bundle/write-raw': WF_DownBundle_WriteRaw(),
             'down-bundle/up-vmdk': WF_DownBundle_UpVMDK(),
             'read-raw/up-bundle': WF_ReadRaw_UpBundle(),
             'down-vmdk/up-bundle': WF_DownVMDK_UpBundle(),
             'down-parts/write-raw': WF_DownBundle_WriteRaw()} # this workflow is same as down-bundle/write-raw (TODO: delete?)

# global arguments, apply to all workflows
parser = argparse.ArgumentParser(prog='euca-run-workflow', description='Run an Imaging Toolkit workflow.')
parser.add_argument('-l', '--list', required=False, help='Lists the available workflows', action="store_true")
subparsers = parser.add_subparsers(dest='name', help='Workflows help')

# let each workflow add its own arguments, all as optional
for name in WORKFLOWS:
    WORKFLOWS[name].add_arguments(name, subparsers)
args = parser.parse_args()

# let each workflow ensure it sees required dependencies
for name in WORKFLOWS:
    WORKFLOWS[name].check_deps(args)

if args.list:
    for name in WORKFLOWS:
        if len(WORKFLOWS[name].problems) == 0:
            print "%30s: %s" % (name, WORKFLOWS[name].description)
    sys.exit(0)

# run the desired workflow
try:
    WORKFLOWS[args.name].execute(args)
except KeyError:
    print "unknown workflow '" + args.name + "'"
    sys.exit(2)
except WF_InsufficientArguments, e:
    print "insufficient arguments for workflow '" + args.name + "'"
except WF_InsufficientDependencies, e:
    print "workflow '" + args.name + "' is unavailable! Problems:"
    for problem in e.args[0]:
        print "\t - " + problem
