package edu.ucsb.eucalyptus.admin.client.ImageStore;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.VerticalPanel;
import com.google.gwt.user.client.ui.SimplePanel;
import com.google.gwt.user.client.Timer;

import com.google.gwt.user.client.rpc.AsyncCallback;  

import com.google.gwt.core.client.GWT;


public class ImageStoreWidget extends Composite {

    private final ImageStoreClient client;

    private SimplePanel imageSectionsPanelContainer = new SimplePanel();
    private VerticalPanel imageSectionsPanel = new VerticalPanel();
    private StatusWidget statusWidget = new StatusWidget();
    private SearchWidget searchWidget = new SearchWidget();
    private Label errorLabel = new Label();
    private boolean errorOnUserAction = false;

    private ResponseHandler responseHandler = new ResponseHandler();
    private ResponseHandler searchResponseHandler = new SearchResponseHandler();
    private ResponseHandler userRequestResponseHandler = new UserRequestResponseHandler();
    private RunActionInstallHandler runActionInstallHandler = new RunActionInstallHandler();
    private RunActionCancelHandler runActionCancelHandler = new RunActionCancelHandler();
    private RunActionClearErrorHandler runActionClearErrorHandler = new RunActionClearErrorHandler();

    private ReloadTimer reloadTimer = new ReloadTimer();

    private static class ImageData {
        ImageInfo info = null;
        ImageState state = null;
        List<ImageWidget> widgets = null;

        ImageWidget createImageWidget() {
            ImageWidget imageWidget = null;
            if (info != null && state != null) {
                if (widgets == null) {
                    widgets = new ArrayList<ImageWidget>();
                }
                imageWidget = new ImageWidget(info, state);
                widgets.add(imageWidget);
            }
            return imageWidget;
        }
    }

    private Map<String,ImageData> imageMap = new HashMap<String,ImageData>();

    public ImageStoreWidget(ImageStoreClient client) {
        this.client = client;

        final VerticalPanel verticalPanel = new VerticalPanel();
        verticalPanel.add(searchWidget);
        verticalPanel.add(errorLabel);
        verticalPanel.add(statusWidget);
        verticalPanel.add(imageSectionsPanelContainer);
        imageSectionsPanelContainer.setWidget(imageSectionsPanel);
        imageSectionsPanelContainer.setStyleName("istore-sections-panel");
        initWidget(verticalPanel);
        setStyleName("istore-image-store-widget");
        errorLabel.setStyleName("istore-global-error-message");

        reloadTimer.scheduleRepeating(5000);

        client.getDashboard(responseHandler);

        searchWidget.addSearchHandler(new SearchHandler<SearchWidget>() {
            public void onSearch(SearchEvent<SearchWidget> searchEvent) {
                String searchText = searchEvent.getSearchText();
                // The searchResponseHandler will remove the "in progress"
                // status which is set automatically by the widget itself.
                if (searchText.length() == 0) {
                    ImageStoreWidget.this.client.getDashboard(searchResponseHandler);
                } else {
                    ImageStoreWidget.this.client.search(searchText, searchResponseHandler);
                }
            }
        });

        statusWidget.addClearErrorHandler(runActionClearErrorHandler);
    }

    private void updateDisplay(ImageStoreResponse response,
                               boolean updateRequestedByUser) {
        /* The following logic ensures that errors returned as a result
         * of a user action won't be overriden by an error generated by
         * an automatic update.  Also, automatic updates which succeed
         * won't erase an error which was caused by a user action, so
         * an error which resulted from a user action will only be
         * cleared by another successful user action, or replaced by
         * another user action error. */
        String errorMessage = response.getErrorMessage();
        if (!errorOnUserAction || updateRequestedByUser) {
            if (errorMessage != null) {
                errorOnUserAction = updateRequestedByUser;
                errorLabel.setText(errorMessage);
                errorLabel.setVisible(true);
            } else {
                errorOnUserAction = false;
                errorLabel.setVisible(false);
            }
        }
        if (response.hasImageSections()) {
            // If we got a full new payload, reset the in progress listing,
            // otherwise just update it.
            statusWidget.clear();
        }
        for (ImageInfo imageInfo : response.getImageInfos()) {
            putImageInfo(imageInfo);
        }
        for (ImageState imageState : response.getImageStates()) {
            putImageState(imageState);
        }
        if (response.hasImageSections()) {
            imageSectionsPanel = new VerticalPanel();
            for (ImageSection imageSection : response.getImageSections()) {
                addImageSection(imageSection);
            }
            imageSectionsPanelContainer.setWidget(imageSectionsPanel);
        }
    }

    private void putImageInfo(ImageInfo imageInfo) {
        statusWidget.putImageInfo(imageInfo);
        ImageData imageData = imageMap.get(imageInfo.getUri());
        if (imageData == null) {
            imageData = new ImageData();
            imageMap.put(imageInfo.getUri(), imageData);
        }
        imageData.info = imageInfo;
    }

    private void putImageState(ImageState imageState) {
        statusWidget.putImageState(imageState);
        ImageData imageData = imageMap.get(imageState.getImageUri());
        if (imageData == null) {
            imageData = new ImageData();
            imageData.state = imageState;
            imageMap.put(imageState.getImageUri(), imageData);
        } else {
            imageData.state = imageState;
            if (imageData.widgets != null) {
                for (ImageWidget imageWidget : imageData.widgets) {
                    imageWidget.setImageState(imageState);
                }
            }
        }
    }

    private ImageWidget createImageWidget(String imageUri) {
        ImageData imageData = imageMap.get(imageUri);
        if (imageData != null) {
            ImageWidget imageWidget = imageData.createImageWidget();
            imageWidget.addInstallHandler(runActionInstallHandler);
            imageWidget.addCancelHandler(runActionCancelHandler);
            imageWidget.addClearErrorHandler(runActionClearErrorHandler);
            return imageWidget;
        }
        return null;
    }

    private void addImageSection(ImageSection imageSection) {
        ImageSectionWidget imageSectionWidget = new ImageSectionWidget(imageSection);
        for (String uri : imageSection.getImageUris()) {
            ImageWidget imageWidget = createImageWidget(uri);
            if (imageWidget != null) {
                imageSectionWidget.addImageWidget(imageWidget);
            }
        }
        imageSectionsPanel.add(imageSectionWidget);
    }

    private void reloadStates() {
        List<ImageInfo> imageInfos = new ArrayList<ImageInfo>();
        for (ImageData imageData : imageMap.values()) {
            if (imageData.info != null) {
                imageInfos.add(imageData.info);
            }
        }
        // Must ask even if there are no infos currently known,
        // since it is possible that the proxy will return other
        // details about other on going changes.
        client.getImageStates(imageInfos, responseHandler);
    }

    private class ReloadTimer extends Timer {
        public void run() {
            if (isVisible()) {
                reloadStates();
            }
        }
    }

    private class ResponseHandler implements AsyncCallback<ImageStoreResponse> {
        protected boolean wasRequestedByUser = false;

        public void responseReceived() {}

        public void onSuccess(ImageStoreResponse response) {
            responseReceived();
            updateDisplay(response, wasRequestedByUser);
        }

        public void onFailure(Throwable caught) {
            responseReceived();
            updateDisplay(JSONImageStoreResponse.fromString("{}"),
                          wasRequestedByUser);
            errorLabel.setText("Error: " + caught.getMessage());
            errorLabel.setVisible(true);
            errorOnUserAction = errorOnUserAction || wasRequestedByUser;
        }

    }

    private class UserRequestResponseHandler extends ResponseHandler { 
        { wasRequestedByUser = true; }
    }

    private class SearchResponseHandler extends UserRequestResponseHandler { 
        public void responseReceived() {
            searchWidget.setInProgress(false);
        }
    }

    private class ActionResponseHandler extends UserRequestResponseHandler { 
        private ImageWidget imageWidget;
        public ActionResponseHandler(ImageWidget imageWidget) {
            this.imageWidget = imageWidget;
        }
        public void responseReceived() {
            super.responseReceived();
            imageWidget.setInProgress(false);
        }
    }

    private class RunActionInstallHandler implements InstallHandler<ImageWidget> {
        public void onInstall(InstallEvent<ImageWidget> event) {
            ImageWidget targetWidget = event.getTarget();
            ImageState imageState = targetWidget.getImageState();
            client.runAction(imageState, ImageState.Action.INSTALL,
                             new ActionResponseHandler(targetWidget));
        }
    }

    private class RunActionCancelHandler implements CancelHandler<ImageWidget> {
        public void onCancel(CancelEvent<ImageWidget> event) {
            ImageWidget targetWidget = event.getTarget();
            ImageState imageState = targetWidget.getImageState();
            client.runAction(imageState, ImageState.Action.CANCEL,
                             new ActionResponseHandler(targetWidget));
        }
    }

    private class RunActionClearErrorHandler implements ClearErrorHandler<ImageState> {
        public void onClearError(ClearErrorEvent<ImageState> event) {
            client.runAction(event.getTarget(), ImageState.Action.CLEAR_ERROR,
                             userRequestResponseHandler);
        }
    }

}
